var documenterSearchIndex = {"docs":
[{"location":"","page":"Getting started","title":"Getting started","text":"CurrentModule = SubspacePreservingSparsification\nDocTestSetup = quote\n    using SparseArrays\n    using SubspacePreservingSparsification\nend","category":"page"},{"location":"#API-reference","page":"Getting started","title":"API reference","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Modules = [SubspacePreservingSparsification]\nOrder   = [:function, :type]","category":"page"},{"location":"#SubspacePreservingSparsification.bin_sparse_matrix!-Union{Tuple{T}, Tuple{AbstractArray{T}, SparseArrays.AbstractSparseMatrixCSC, Integer}} where T","page":"Getting started","title":"SubspacePreservingSparsification.bin_sparse_matrix!","text":"bin_sparse_matrix!(M::AbstractArray, M_id::AbstractSparseMatrixCSC, max_num_bins::Integer)\n\nCompute a Binning pattern in M_id from the sparsity pattern in M_id.\n\nM_id is SparseMatrixCSC{Int64, Int64} with the same shape as M, when handed over it contains only 0 and 1. After usage it contains an Integer corresponding to a bin or 0. According to the Binning Pattern, similar valued entries can be considered the same.\n\nM is the matrix whose entries are used for binning. max_num_bins is the maximum number of bins and must be non-negative, if max_num_bins=0, no binning is performed and only the sparsity pattern in M_id is used then.\n\nSee also: sparsify, sparsity_pattern.\n\nExamples\n\njulia> bin_sparse_matrix!([4 1 4.01; 0.1 17.1 17; 0.2 4 29], sparse([1 0 1; 0 1 1; 0 0 1]), 200)\n3×3 SparseMatrixCSC{Int64, Int64} with 5 stored entries:\n 1  ⋅  1\n ⋅  2  2\n ⋅  ⋅  3\n\n\n\n\n\n","category":"method"},{"location":"#SubspacePreservingSparsification.pinv_qr-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Getting started","title":"SubspacePreservingSparsification.pinv_qr","text":"pinv_M, rnull_optional, lnull_optional = pinv_qr(M::AbstractArray)\n\nComputes Moore-Penrose pseudoinverse of M using a rank-revealing QR factorization and optionally returns an orthonormal basis for right and left null-space. This can be significantly faster than using SVD for computing the pseudoinverse.  Moreover, A can be sparse or dense.\n\nExamples\n\njulia> pinv_qr([3 8 17; 2 1 4; 8 3 21])\n([-0.10344827586206914 1.344827586206895 -0.17241379310344793;0.1149425287356321 0.8390804597701144 -0.2528735632183907;0.022988505747126506 -0.6321839080459762 0.1494252873563217], Matrix{Float64}(undef, 3, 0), Matrix{Float64}(undef, 3, 0))\n\n\n\n\n\n","category":"method"},{"location":"#SubspacePreservingSparsification.sparsify-Union{Tuple{T}, Tuple{AbstractArray{T}, Real, Real, Integer}, Tuple{AbstractArray{T}, Real, Real, Integer, Any}} where T","page":"Getting started","title":"SubspacePreservingSparsification.sparsify","text":"sparsify(M::AbstractArray, ratio::Real, p::Real, max_num_bins::Integer,\n    impose_null_spaces=false::Bool)\n\nCompute a SparseMatrixCSC{Float64, Int64} X for a matrix M, that is sparse and spectrally close to M, especially in the lower end of the singular value spectrum.\n\nWrapper function over all functionality.\n\nCompute a sparse approximation for a matrix M. First the sparsity pattern is computed with a ratio in 01 that determines the sparsity (0 means more sparse, 1 means less) and with p in (0 infty  that determines which norm is used to find the sparsity pattern. Next the sparsity pattern is used to find a binning pattern, the non-negative integer max_num_bins determines whats the maximum number of bins is (200-1000 is a reasonable choice). max_num_bins=0 means no binning is performed and can lead to significant slowdown. Then an optimization problem, with constraints given by the binning pattern, is solved to find a sparse approximation X for M. If impose_null_spaces=true, another optimization problem is solved that ensures that X and M have the same null space.\n\nSee also: sparsity_pattern, bin_sparse_matrix!.\n\nExamples\n\njulia> sparsify([16.99 65; 0.1 17.01], 0.6, 2, 200)\n2×2 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n 16.8041  64.2499\n   ⋅      16.8041\n\n\n\n\n\n","category":"method"},{"location":"#SubspacePreservingSparsification.sparsity_pattern","page":"Getting started","title":"SubspacePreservingSparsification.sparsity_pattern","text":"sparsity_pattern(M::AbstractArray, ratio::Real, p::Real, min_per_row=0::Integer, min_per_col=0::Integer)\n\nCompute a pattern matrix M_pat which is a p-norm sparsity pattern for M.\n\nM_pat is a sparse SparseMatrixCSC{Int64, Int64} of the same shape as M and contains only 0 or 1.\n\nratio should be in 01.  p should be in (0 infty \n\nmin_per_row is the minimum number of non-zeros needed per row.\nmin_per_col is the minimum number of non-zeros needed per column.\n\nDefaults are 0.\n\nSee also: sparsify, bin_sparse_matrix!.\n\nExamples\n\njulia> sparsity_pattern([4 1; 0.1 17], 0.6, 2)\n2×2 SparseMatrixCSC{Int64, Int64} with 2 stored entries:\n 1  ⋅\n ⋅  1\n\n\n\n\n\n","category":"function"}]
}
