var documenterSearchIndex = {"docs":
[{"location":"generated/example/","page":"example","title":"example","text":"EditURL = \"<unknown>/literate/example.jl\"","category":"page"},{"location":"generated/example/#example","page":"example","title":"example","text":"","category":"section"},{"location":"generated/example/","page":"example","title":"example","text":"Lets try to find a sparse representation for a matrix, so that the Frobeniusnorm of the difference is as small as possible. Lets consider a symmetric matrix M:","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"using SubspacePreservingSparsification\nusing SparseArrays\nusing LinearAlgebra\nM = [17.05 16.98 0.3 6.99 7; 16.98 0.2 7.1 6.9 0; 0.3 7.1 -12 0.01 17; 6.99 6.9 0.01 -11.97 0; 7 0 17 0 -0.1]","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"First we calculate a sparsity pattern:","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"M_id = sparsity_pattern(M, 0.6, 2)","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"For every column and every row of the Matrix the function solves the optimization problem","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"max_Z x - xcirc Z(x)_0 st ","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"beginalign*\n(Z(x))_i = 0  textor 1 \nZ(x)_0 ge N \nx - xcirc Z(x)_p \tle  (1-q)x_p\nendalign*","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"where Z is the sparsity pattern for the column or row. N is a maximum number for non zero entries, q is a factor that controls how sparse the the row or column should be. All the individual row and column patter are overlayed, if either row or column or both return a one for an entry the entry is one. This ensures that the pattern will preserve different Subspaces of the Matrix.","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"Than we can take the sparsity pattern and modify it to a binning pattern:","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"bin_sparse_matrix!(M, M_id, 200)","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"The function looks at the maximum and minimum values of the matrix and then finds a partition of the negative and positive area according to the specified maximum number of bins. For each entry of the matrix it is checked to which bin it belongs to. The binning controls the number of unknowns and so the computation cost to solve the optimization problem. It also typically improves the conditioning of the optimization problem.","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"With the binning pattern we can find the Matrix so that the norm of the difference is as small as possible and so that the binning constrains are fullfilled:","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"binned_minimization(M_id, zeros(5, 5), Matrix{Float64}(I, 5, 5), M)","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"The function solves the optimization problem","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"min M - X_F  st","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"X texthas the specified sparsity pattern B(M) = M_id","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"Of course our example optimization problem is not too interesting, because without the binning only some entries are set to zero, while the others remain the same. However, more sophisticated optimization problems can be used here.","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"We can also use the sparsify function on M:","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"sparsify(M, 0.6, 2, 200)","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"This function calculates the sparsity and binning pattern like we did and uses as optimization problem","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"min frac12 sumlimits_i=1^r frac1sigma_i^2 left( X - Mright) v_i_2^2\n+ frac12 sumlimits_i=1^r frac1sigma_i^2 left( X^* - M^*right) u_i_2^2","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"where r is the rank, sigma_i are the r biggest singular values, v_i the corresponding right singular vectors and u_i the corresponding left singular vectors of M. M^* denotes the conjugate transpose of M. The function compares the action of the unknown matrix X with the action of M on the singular vectors of M and penalizes the differences in near null-space with larger weights. It can be formulatet in the form","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"X M^+(M^+)^* + (M^+)^*M^+X = MM^+(M^+)^* (M^+)^*M^+M","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"where M^+ is the pseudo inverse of M. We can also set impose_null_spaces true:","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"sparsify(M, 0.6, 2, 200, true)","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"Then after the described optimization problem was solved the function also solves an additional optimization problem that ensures that the left and right null-spaces are preserved exactly. Because our matrix has full rank this makes no difference in our case.","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"","category":"page"},{"location":"generated/example/","page":"example","title":"example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SubspacePreservingSparsification\nend","category":"page"},{"location":"#SubspacePreservingSparsification.jl","page":"Home","title":"SubspacePreservingSparsification.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Implementation of an algorithm, that takes a real Matrix M and finds a sparse approximation of the same size. The algorithm was developed by Chetan Jhurani under the name sparse spectral approximation (SSA). See https://github.com/cjhurani/txssa for more detailed documentation, also with regard to the mathematical background, and for implementations in C/C++ and in Matlab.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this package and its dependencies, open the Julia REPL and run ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add SubspacePreservingSparsification","category":"page"},{"location":"#API-reference","page":"Home","title":"API reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SubspacePreservingSparsification]\nOrder   = [:function, :type]","category":"page"},{"location":"#SubspacePreservingSparsification.bin_sparse_matrix!-Union{Tuple{T}, Tuple{AbstractArray{T}, SparseArrays.AbstractSparseMatrixCSC, Integer}} where T","page":"Home","title":"SubspacePreservingSparsification.bin_sparse_matrix!","text":"bin_sparse_matrix!(M::AbstractArray, M_id::AbstractSparseMatrixCSC, max_num_bins::Integer)\n\nCompute a Binning pattern in M_id from the sparsity pattern in M_id.\n\nM_id is SparseMatrixCSC{Int64, Int64} with the same shape as M, when handed over it contains only 0 and 1. After usage it contains an Integer corresponding to a bin or 0. According to the Binning Pattern, similar valued entries can be considered the same.\n\nM is the matrix which entries are used for binning. max_num_bins is the maximum number of bins and must be non-negative, if max_num_bins=0, no binning is performed and only the sparsity pattern in M_id is used then.\n\nSee also: sparsify, sparsity_pattern.\n\nExamples\n\njulia> bin_sparse_matrix!([4 1 4.01; 0.1 17.1 17; 0.2 4 29], sparse([1 0 1; 0 1 1; 0 0 1]), 200)\n3×3 SparseMatrixCSC{Int64, Int64} with 5 stored entries:\n 1  ⋅  1\n ⋅  2  2\n ⋅  ⋅  3\n\n\n\n\n\n","category":"method"},{"location":"#SubspacePreservingSparsification.binned_minimization-Union{Tuple{T}, Tuple{SparseArrays.AbstractSparseMatrixCSC, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T","page":"Home","title":"SubspacePreservingSparsification.binned_minimization","text":"binned_minimization(M_id::AbstractSparseMatrixCSC,\nB::AbstractMatrix, C::AbstractMatrix, D::AbstractMatrix)\n\nSolves a optimization problem of the from\n\nY A + B Y = D\n\nunder the binning constraints given in the SparseMatrixCSC{Int64, Int64} M_id.\n\nSee also: sparsify.\n\nExamples\n\njulia> binned_minimization([16.99 65 64.96; 0.1 17.01 0.1], sparse([1 2 2; 0 1 0]), Matrix(I, 3, 3) , Matrix(I, 2, 2), Matrix(I, 2, 3))\n2×3 SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n 0.5  0.0  0.0\n  ⋅   0.5   ⋅\n\n\n\n\n\n","category":"method"},{"location":"#SubspacePreservingSparsification.pinv_qr-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Home","title":"SubspacePreservingSparsification.pinv_qr","text":"pinv_M, rnull_optional, lnull_optional = pinv_qr(M::AbstractArray)\n\nComputes Moore-Penrose pseudoinverse of M using a rank-revealing QR factorization and optionally returns an orthonormal basis for right and left null-space. This can be significantly faster than using SVD for computing the pseudoinverse.  Moreover, A can be sparse or dense.\n\nExamples\n\njulia> pinv_qr([3 8 17; 2 1 4; 8 3 21])\n([-0.10344827586206914 1.344827586206895 -0.17241379310344793;0.1149425287356321 0.8390804597701144 -0.2528735632183907;0.022988505747126506 -0.6321839080459762 0.1494252873563217], Matrix{Float64}(undef, 3, 0), Matrix{Float64}(undef, 3, 0))\n\n\n\n\n\n","category":"method"},{"location":"#SubspacePreservingSparsification.sparsify-Union{Tuple{T}, Tuple{AbstractArray{T}, Real, Real, Integer}, Tuple{AbstractArray{T}, Real, Real, Integer, Any}} where T","page":"Home","title":"SubspacePreservingSparsification.sparsify","text":"sparsify(M::AbstractArray, ratio::Real, p::Real, max_num_bins::Integer,\n    impose_null_spaces=false::Bool)\n\nCompute a SparseMatrixCSC{Float64, Int64} X for a matrix M, that is sparse and spectrally close to M, especially in the lower end of the singular value spectrum.\n\nWrapper function over all functionality.\n\nCompute a sparse approximation for a matrix M. First the sparsity pattern is computed with a ratio in 01 that determines the sparsity (0 means more sparse, 1 means less) and with p in (0 infty  that determines which norm is used to find the sparsity pattern.\n\nNext the sparsity pattern is used to find a binning pattern, the non-negative integer max_num_bins determines whats the maximum number of bins is (200-1000 is a reasonable choice). max_num_bins=0 means no binning is performed and can lead to significant slowdown.\n\nThen an optimization problem, with constraints given by the binning pattern, is solved to find a sparse approximation X for M.\n\nIf impose_null_spaces=true, another optimization problem is solved that ensures that X and M have the same null space.\n\nSee also: sparsity_pattern, bin_sparse_matrix!.\n\nExamples\n\njulia> sparsify([16.99 65; 0.1 17.01], 0.6, 2, 200)\n2×2 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n 16.8041  64.2499\n   ⋅      16.8041\n\n\n\n\n\n","category":"method"},{"location":"#SubspacePreservingSparsification.sparsity_pattern","page":"Home","title":"SubspacePreservingSparsification.sparsity_pattern","text":"sparsity_pattern(M::AbstractArray, ratio::Real, p::Real, min_per_row=0::Integer, min_per_col=0::Integer)\n\nCompute a pattern matrix M_pat which is a p-norm sparsity pattern for M.\n\nM_pat is a sparse SparseMatrixCSC{Int64, Int64} of the same shape as M and contains only 0 or 1.\n\nratio is a measure for how sparse the pattern is supposed to be and must be in 01.   p determines which norm is used and should be in (0 infty . min_per_row is the minimum number  of non-zeros needed per row and min_per_col is the minimum number of non-zeros needed per column,  Defaults are 0.\n\nSee also: sparsify, bin_sparse_matrix!.\n\nExamples\n\njulia> sparsity_pattern([4 1; 0.1 17], 0.6, 2)\n2×2 SparseMatrixCSC{Int64, Int64} with 2 stored entries:\n 1  ⋅\n ⋅  1\n\n\n\n\n\n","category":"function"}]
}
